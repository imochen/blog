<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>普通的前端小站</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://imochen.com/"/>
  <updated>2016-01-10T04:47:40.000Z</updated>
  <id>https://imochen.com/</id>
  
  <author>
    <name>墨尘/*V5*/</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端重构之路（组件化）</title>
    <link href="https://imochen.com/2016/01/09/the-path-of-the-front-end-refactoring-componentization/index.html"/>
    <id>https://imochen.com/2016/01/09/the-path-of-the-front-end-refactoring-componentization/index.html</id>
    <published>2016-01-09T13:58:28.000Z</published>
    <updated>2016-01-10T04:47:40.000Z</updated>
    
    <content type="html">&lt;p&gt;距离&lt;a href=&quot;/2015/12/23/the-path-of-the-front-end-refactoring-technology-selection/&quot;&gt;前端重构之路(技术选型篇)&lt;/a&gt;已经过去了近半个月。之前提到说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务端使用&lt;strong&gt;ThinkJS&lt;/strong&gt;已经可以确定了，一些配套模块也都写差不多了。前端还在Vue，Novajs，还是手动实现中徘徊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;期间对&lt;strong&gt;Novajs&lt;/strong&gt;，&lt;strong&gt;Vuejs&lt;/strong&gt;进行了大量的调研，也针对业务调整了相关的开发方式。最终确定了使用&lt;strong&gt;Vuejs&lt;/strong&gt;来进行组件开发，也使用&lt;em&gt;Vuejs&lt;/em&gt;玩出了一套可按需加载的基础组件开发模式。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;要解决的问题&quot;&gt;&lt;a href=&quot;#要解决的问题&quot; class=&quot;headerlink&quot; title=&quot;要解决的问题&quot;&gt;&lt;/a&gt;要解决的问题&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;组件化开发&lt;/li&gt;
&lt;li&gt;按需且支持并行加载&lt;/li&gt;
&lt;li&gt;数据驱动&lt;/li&gt;
&lt;li&gt;服务端渲染&lt;/li&gt;
&lt;li&gt;&lt;em&gt;web component&lt;/em&gt;使用方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;为什么组件化开发？&lt;/strong&gt;&lt;br&gt;低耦合、高复用、便开发、易维护、代码清晰、结构明确等等。结合电商活动的特质，没有理由拒绝组件化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;按需且支持并行加载&lt;/strong&gt;&lt;br&gt;按需加载目的是为了不同组件可以随意进行组合，而无需加载多余的资源。并行加载是指可以让组件资源同时进行加载，而无需使用require等方式异步加载，在加载速度上会有些许提升。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据驱动&lt;/strong&gt;&lt;br&gt;组件化，明确点说是&lt;code&gt;UI组件&lt;/code&gt;。既然是UI组件，必然会有一些DOM类的操作。数据驱动可以让这些操作变的简单，且考虑到业务中某些场景，数据单双向绑定的用处也是不可忽视的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端渲染&lt;/strong&gt;&lt;br&gt;这个带来的性能提高不言而喻。组件不必通过JS去解析，用户在访问页面时已经是渲染好的页面了。当然服务端渲染不仅是输出页面，类似事件绑定，数据绑定之类在渲染后要依然生效。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;web component使用方式&lt;/strong&gt;&lt;br&gt;在组件的使用上，更偏向简单化，无需做太多的操作就可以使用一个功能丰富的组件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;下面这张图是最初我们对组件的期望，和大多数组件化方案一致。有些区别的是增加了颗粒组件，主要用于存储可复用代码片段，节省开发成本。最终打包为一个js和css，js中包含html(模版)。而隔离了css是为了在使用中灵活的根据文件类别进行打包合并。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/images/component-graphic.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于Vuejs的基础组件开发&quot;&gt;&lt;a href=&quot;#基于Vuejs的基础组件开发&quot; class=&quot;headerlink&quot; title=&quot;基于Vuejs的基础组件开发&quot;&gt;&lt;/a&gt;基于Vuejs的基础组件开发&lt;/h2&gt;&lt;p&gt;最初尝试的是&lt;em&gt;novajs&lt;/em&gt;，整体上没有太大的问题，在&lt;em&gt;scss&lt;/em&gt;编译这块遇到了一些问题，不过作者很快解决了，让我十分感动，然后含着泪选择了&lt;em&gt;Vuejs&lt;/em&gt;。（此处主要因为团队原因没有选择&lt;em&gt;novajs&lt;/em&gt;，感兴趣的童鞋可以研究下&lt;a href=&quot;http://novajs.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://novajs.com/&lt;/a&gt;，轻量级web component还是很有优势的）&lt;/p&gt;
&lt;p&gt;在官方给出的示例中，使用&lt;em&gt;webpack&lt;/em&gt;+&lt;em&gt;vue-loader&lt;/em&gt;开发打包，均使用的是全量打包。我们希望组件更灵活，且能根据需要去加载，这种全量打包显然是不合适的。如上篇文章中提到的，要将这种开发打包进行一定的修改，否则是无法使用的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;webpack&lt;/em&gt;确实存在打包完文件大，全量不可分割的问题，但它绝对不是这么弱，否则也不可能受到开发者的青睐。所以拆分打包的问题是可以解决的。&lt;/p&gt;
&lt;p&gt;另外，&lt;em&gt;Vuejs&lt;/em&gt;是可以使用&lt;code&gt;Vue.component&lt;/code&gt;方法进行组件注册，而先不去实例化，在需要用到的组件全部注册完后，再进行实例化。&lt;/p&gt;
&lt;p&gt;这个思路明确了，来看一下，怎么注册组件&lt;br&gt;&lt;figure class=&quot;highlight gradle&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;vue&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; titleTest &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;./title-test.vue&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.component(&lt;span class=&quot;string&quot;&gt;&#39;title-test&#39;&lt;/span&gt; , titleTest );&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;经&lt;em&gt;webpack&lt;/em&gt;编译后，在作用域内，Vue对象是同一个。那么问题就简单了，无论我们注册多少个组件，最终都在一个Vue对象上，只需要对Vue进行实例化即可。&lt;/p&gt;
&lt;p&gt;在&lt;em&gt;webpack&lt;/em&gt;编译的时候，每个组件都会带一个Vue.js，可以使用插件将其提取出来作为公共部分。看一下&lt;code&gt;webpack.config.js&lt;/code&gt;的内容。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//webpack主要配置&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;entry : &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;components/title-test&#39;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;src/components/title-test/index.js&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;string&quot;&gt;&#39;components/banner-test&#39;&lt;/span&gt; : &lt;span class=&quot;string&quot;&gt;&#39;src/components/banner-test/index.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;output : &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	path: &lt;span class=&quot;string&quot;&gt;&#39;./build&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	publicPath: &lt;span class=&quot;string&quot;&gt;&#39;build/&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//按entry配置生成js&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	filename: &lt;span class=&quot;string&quot;&gt;&#39;[name]/index.js&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;plugins : [&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//公共部分抽离，主要是Vuejs&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; webpack.optimize.CommonsChunkPlugin(&lt;span class=&quot;string&quot;&gt;&#39;bootstrap/basic.js&#39;&lt;/span&gt;), &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//css抽离，一个组件一个样式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ExtractTextPlugin(&lt;span class=&quot;string&quot;&gt;&#39;[name]/index.css&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这样，打包完出现了另外一个问题，我们把所有组件都注册了，但是并没有实例化，而经过打包后的&lt;em&gt;Vue&lt;/em&gt;在局部作用域，全局下是无法访问的。搞个启动器将其暴漏到window下，方便随时调用。&lt;br&gt;&lt;figure class=&quot;highlight qml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt;&lt;span class=&quot;string&quot;&gt; Vue from &#39;vue&#39;;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; init = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; luna = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	start( el )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;( init )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;luna已经启动，不能重复start&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;decorator&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			init = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			luna.vm = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;attribute&quot;&gt;el&lt;/span&gt; : el || &lt;span class=&quot;string&quot;&gt;&#39;body&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.luna = luna;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;简单处理了一下，只暴漏必要的东西，启动方法和实例化对象，假设需要实例化多个对象，经过简单改造也是可以满足的。这样的话。&lt;code&gt;webpack.config.js&lt;/code&gt;的entry也对应调整一下。最终经过打包后是酱紫的。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;├── bootstrap &lt;span class=&quot;comment&quot;&gt;#启动器相关&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   ├── basic.js &lt;span class=&quot;comment&quot;&gt;#包含vuejs及组件标识&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;│   └── index.js &lt;span class=&quot;comment&quot;&gt;#启动器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;└── components &lt;span class=&quot;comment&quot;&gt;#组件文件夹&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ├── title-test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    │   ├── index.css&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    │   └── index.js&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    └── banner-test&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ├── index.css&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        └── index.js&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;因为Vue.js在&lt;em&gt;basic&lt;/em&gt;中，所以我们要先加载basic。而启动器文件（bootstrap/index.js）我们最好还是让这个文件在组件加载后在加载，从流程上也更清晰。&lt;/p&gt;
&lt;h2 id=&quot;享受组件的乐趣&quot;&gt;&lt;a href=&quot;#享受组件的乐趣&quot; class=&quot;headerlink&quot; title=&quot;享受组件的乐趣&quot;&gt;&lt;/a&gt;享受组件的乐趣&lt;/h2&gt;&lt;p&gt;通过针对各个问题的解决。这些个组件可以在任意地方使用，而最后仅需解决的一个问题就是，根据所使用的组件进行打包，js和js打包到一起，css和css打包到一起，或者使用combo合并请求。&lt;/p&gt;
&lt;p&gt;但是仍然存在一个问题，&lt;em&gt;Vuejs&lt;/em&gt;目前是不支持服务端渲染的，在Github上也有人写了一个叫&lt;code&gt;Vue-server&lt;/code&gt;的服务端渲染工具，但是目前为止，它只能渲染静态数据，一些&lt;em&gt;Vuejs&lt;/em&gt;的特性及方法在渲染后将会失效。这就意味着，页面的解析要在用户端进行，经压测，500以下的组件解析是可以接受的。而SEO上会受到较大的影响，如需解决SEO问题，在没有服务端渲染的情况下也有其他方法，由于博主没有尝试就不乱讲了。&lt;/p&gt;
&lt;p&gt;综合考虑之下，暂时无法服务端渲染也可以接受。这样的基础组件可以配合常规开发模式进行开发，也可以组件化组装。经过压缩后，基础文件仅70k。GZIP后大概20k多些，使用简单，灵活多变。&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--组件样式--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;link&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;rel&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;href&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;component??title-test.css,banner-test.css&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--组件标记--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;title-test&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;:data&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;title-test&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;banner-test&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;:data&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;banner-test&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--基础文件--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;bootstrap/basic.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--组件JS--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;sript&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;component??title-test.js,banner-test.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;handlebars&quot;&gt;&lt;span class=&quot;xml&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--启动器--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;src&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;bootstrap/index.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;undefined&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;actionscript&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;//手动发射&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	luna.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;方案的确定走出了第一步，仅仅确定以上方式是远远不够的。在团队中，怎么去协作开发？怎么保证统一规范？怎么最大化节省开发成本？怎么最快速度上手？这些都是要考虑的内容。&lt;/p&gt;
&lt;p&gt;篇幅有限，关于团队化组件开发工具，日后再作单独的介绍。预览版已经放到了博主的Github和NPM了，感兴趣的同学可以去看下。&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;距离&lt;a href=&quot;/2015/12/23/the-path-of-the-front-end-refactoring-technology-selection/&quot;&gt;前端重构之路(技术选型篇)&lt;/a&gt;已经过去了近半个月。之前提到说&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务端使用&lt;strong&gt;ThinkJS&lt;/strong&gt;已经可以确定了，一些配套模块也都写差不多了。前端还在Vue，Novajs，还是手动实现中徘徊。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;期间对&lt;strong&gt;Novajs&lt;/strong&gt;，&lt;strong&gt;Vuejs&lt;/strong&gt;进行了大量的调研，也针对业务调整了相关的开发方式。最终确定了使用&lt;strong&gt;Vuejs&lt;/strong&gt;来进行组件开发，也使用&lt;em&gt;Vuejs&lt;/em&gt;玩出了一套可按需加载的基础组件开发模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端重构" scheme="https://imochen.com/tags/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84/"/>
    
      <category term="组件化" scheme="https://imochen.com/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Vuejs" scheme="https://imochen.com/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>前端重构之路（技术选型篇）</title>
    <link href="https://imochen.com/2015/12/23/the-path-of-the-front-end-refactoring-technology-selection/index.html"/>
    <id>https://imochen.com/2015/12/23/the-path-of-the-front-end-refactoring-technology-selection/index.html</id>
    <published>2015-12-23T09:48:54.000Z</published>
    <updated>2016-01-09T16:40:54.000Z</updated>
    
    <content type="html">&lt;p&gt;多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：以下文中提到的技术方案每个点均可长篇大论，这里仅做概述。日后根据重构进度逐步更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;业务背景&quot;&gt;&lt;a href=&quot;#业务背景&quot; class=&quot;headerlink&quot; title=&quot;业务背景&quot;&gt;&lt;/a&gt;业务背景&lt;/h2&gt;&lt;p&gt;HIGO前端团队组建稍晚一些，在前端业务层继承了服务端开发带来的著名的PHP框架YII。主要用于微信签名，静态资源上CDN，还有一些简单的服务端逻辑处理。&lt;/p&gt;
&lt;p&gt;纯前端方面，并没有特别框架。大部分业务依赖Zepto，使用RequireJS来处理依赖。整个业务依赖YII发布，但其实大多只是用到了view层而已。&lt;/p&gt;
&lt;p&gt;在很长一段时间里，这个方案并没有特别大的问题。随着前端开发人员的不断加入，以及业务复杂度的逐步增长，基于YII+RequireJS的这种整体方案也逐步暴漏出很多缺陷。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;YII并没有发挥其真正的作用。&lt;/li&gt;
&lt;li&gt;由于业务复杂度不断增长，代码维护变得很困难。&lt;/li&gt;
&lt;li&gt;单纯的RequireJS没有完善的工程化。&lt;/li&gt;
&lt;li&gt;PHP是有成本的，不是所有的前端都熟悉PHP。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;重构契机&quot;&gt;&lt;a href=&quot;#重构契机&quot; class=&quot;headerlink&quot; title=&quot;重构契机&quot;&gt;&lt;/a&gt;重构契机&lt;/h2&gt;&lt;p&gt;电商的重头是活动，在之前的活动中，每月的大促活动都需要我们前端去手动开发，这显然是有问题的。&lt;/p&gt;
&lt;p&gt;为了改变这种现状，我们先是开发了一批组件，运营人员可以根据需要选择组件来创建一个活动页面。&lt;/p&gt;
&lt;p&gt;很快，我们便发现了新的问题。运营会配上百个组件，因为我们的YII没有完全发挥作用，所以，在组件渲染上，我们只有拿到了数据（异步接口取数据），才能知道哪些组件会被用到，进而去加载组件。带来的结果是，加载异常缓慢。&lt;/p&gt;
&lt;p&gt;当然这里还有一些其他问题，组件的逻辑太重，服务端不能按照前端要求的格式给数据（不必深究，给不了就是给不了，哈哈）。我们只能在前端先去判断，再进行渲染。&lt;/p&gt;
&lt;p&gt;虽然经历了多次&lt;strong&gt;由于历史原因，因为时间问题&lt;/strong&gt;，但是考虑到一个长期健康的发展，重构势在必行！！！&lt;/p&gt;
&lt;h2 id=&quot;针对业务选技术&quot;&gt;&lt;a href=&quot;#针对业务选技术&quot; class=&quot;headerlink&quot; title=&quot;针对业务选技术&quot;&gt;&lt;/a&gt;针对业务选技术&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;改变必然是痛苦的，只有改变才能成长，所以成长也是痛苦的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h3&gt;&lt;p&gt;结合种种原因，YII这一层是不能放弃的，当然YII是要放弃的。那这就没得考虑了，NodeJS当仁不让啊。那我们先看一下要解决的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;充当Logic层，处理服务端数据。&lt;/li&gt;
&lt;li&gt;微信签名等强依赖服务端需求。&lt;/li&gt;
&lt;li&gt;页面前置渲染，静态化等。&lt;/li&gt;
&lt;li&gt;承担高并发（优于YII）。&lt;/li&gt;
&lt;li&gt;必要的缓存机制。&lt;/li&gt;
&lt;li&gt;其他服务端干的活。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NodeJS社区欣欣向荣，各种框架眼花缭乱。著名的有&lt;strong&gt;Express&lt;/strong&gt;，&lt;strong&gt;Koa&lt;/strong&gt;，还有数不清的非著名框架。&lt;/p&gt;
&lt;p&gt;在尝试了具有代表性的几个框架之后发现，结合业务，这些框架似乎都没那么完美。不完美是什么意思呢？以&lt;strong&gt;Express&lt;/strong&gt;为例，我需求很多加工才能将其使用到业务中。而且存在一个模块的风险，使用的第三方模块越多，风险就越大。本着稳定为主的目的，暂且先pass掉&lt;strong&gt;Express&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这里要提到一个国产著名NodeJS框架 &lt;a href=&quot;https://thinkjs.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ThinkJS&lt;/a&gt;。这个框架从1.x的时候就曾有过接触，上手简单，功能强大，稳定性好。目前已经是2.x版本，不仅继承了1.x各种优势，而且支持直接使用ES6/ES7来开发，对于前端来讲，这无疑是一大诱惑。当然选择一个框架，最最重要的是功能，性能，稳定性。&lt;strong&gt;ThinkJS&lt;/strong&gt;在以上几点均有优秀的表现。经过调研及动手实践，&lt;strong&gt;ThinkJS&lt;/strong&gt;在我们业务基础上有出色的表现。&lt;/p&gt;
&lt;p&gt;这里还要提到另外一个原因：博主有幸曾和ThinkJS作者共事，售后服务五星好评。当然对所有用户来讲，作者都是一视同仁的。感兴趣的也可以加入&lt;strong&gt;ThinkJS官方交流群(339337680)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h3&gt;&lt;p&gt;前端方面，这次重构主要服务业务是&lt;strong&gt;组件建站&lt;/strong&gt;。那首先要从组件入手了。如果说服务端框架的选择经历了一番择决。前端框架/库的选择简直日了dog了，先列一下吧。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;React&lt;/li&gt;
&lt;li&gt;AngularJS&lt;/li&gt;
&lt;li&gt;Polymer&lt;/li&gt;
&lt;li&gt;vue&lt;/li&gt;
&lt;li&gt;backbone&lt;/li&gt;
&lt;li&gt;novajs(Polymer mini)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先不要奇怪列举了这么多相关不相关的，简单过一下。暂且忽略各个库/框架的大小，先从功能看。&lt;/p&gt;
&lt;h4 id=&quot;React&quot;&gt;&lt;a href=&quot;#React&quot; class=&quot;headerlink&quot; title=&quot;React&quot;&gt;&lt;/a&gt;React&lt;/h4&gt;&lt;p&gt;单向数据流，优秀的dom diff算法，可惜这些我们都用不到，pass。&lt;/p&gt;
&lt;h4 id=&quot;AngularJS&quot;&gt;&lt;a href=&quot;#AngularJS&quot; class=&quot;headerlink&quot; title=&quot;AngularJS&quot;&gt;&lt;/a&gt;AngularJS&lt;/h4&gt;&lt;p&gt;SPA(单页应用)中的王者，我们不是单页应用，pass。&lt;/p&gt;
&lt;h4 id=&quot;Polymer&quot;&gt;&lt;a href=&quot;#Polymer&quot; class=&quot;headerlink&quot; title=&quot;Polymer&quot;&gt;&lt;/a&gt;Polymer&lt;/h4&gt;&lt;p&gt;Google出品，代表组件化未来的 web component。这差不多就是我们需要的了，可惜兼容性不怎么好。&lt;/p&gt;
&lt;h4 id=&quot;Vue&quot;&gt;&lt;a href=&quot;#Vue&quot; class=&quot;headerlink&quot; title=&quot;Vue&quot;&gt;&lt;/a&gt;Vue&lt;/h4&gt;&lt;p&gt;vue提供的组件正是我们所需要的，可是其他功能又多余了。而且有一个问题，vue似乎没有考虑过组件动态加载，开发模式中全量打包让我接受不了，如果选择vue，意味着，我需要自己再给他配一套独特的编译系统。然后再增加一个动态打包。暂且搁置一下，没有其他方案的话再回头看。&lt;/p&gt;
&lt;h4 id=&quot;Backbone&quot;&gt;&lt;a href=&quot;#Backbone&quot; class=&quot;headerlink&quot; title=&quot;Backbone&quot;&gt;&lt;/a&gt;Backbone&lt;/h4&gt;&lt;p&gt;backbone不做评价了。这都是MVC类型的，本不该进入候选，你懂的。&lt;/p&gt;
&lt;h4 id=&quot;Novajs&quot;&gt;&lt;a href=&quot;#Novajs&quot; class=&quot;headerlink&quot; title=&quot;Novajs&quot;&gt;&lt;/a&gt;Novajs&lt;/h4&gt;&lt;p&gt;小巧的web component框架，奇舞团女神&lt;a href=&quot;https://github.com/melonHuang/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;瓜瓜&lt;/a&gt;出品。novajs只做了一件事，就是web component。当然提供的一些双向绑定之类的功能，暂时可能用不到了。不过没关系，核心功能有90%以上是有用的。当然novajs也不是没有缺点。开发和部署差异太大，官方没有提供一套完善的开发部署流程方案。不过这个不重要了。配合我们业务可以自己完善，相比vue，这个成本低很多。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;&lt;a href=&quot;#写在最后&quot; class=&quot;headerlink&quot; title=&quot;写在最后&quot;&gt;&lt;/a&gt;写在最后&lt;/h2&gt;&lt;p&gt;目前为止，服务端使用&lt;strong&gt;ThinkJS&lt;/strong&gt;已经可以确定了，一些配套模块也都写差不多了。前端还在&lt;strong&gt;Vue&lt;/strong&gt;，&lt;strong&gt;Novajs&lt;/strong&gt;，还是手动实现中徘徊。因为&lt;strong&gt;组件建站&lt;/strong&gt;是一个相对独立的业务，可以单独考虑其前端框架，但重构是一个全量的迭代，多考虑一些总没有坏处。&lt;/p&gt;
&lt;p&gt;技术选型，除了上述提到的客观因素，还要考虑团队情况。学习成本，上手速度都是很必要的因素，这里就不展开说了。重构进行时…&lt;/p&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;多年以后，你再也不是那个切图仔，而前端也不再是简单的拼页面。从最初我们高举规范化大旗，什么语意化命名，统一规范。到今天，我们对工程化的信仰。每个前端团队也都在为自己的业务不断探索，追求更加完善的工程化解决方案。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：以下文中提到的技术方案每个点均可长篇大论，这里仅做概述。日后根据重构进度逐步更新。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="前端重构" scheme="https://imochen.com/tags/%E5%89%8D%E7%AB%AF%E9%87%8D%E6%9E%84/"/>
    
      <category term="ThinkJS" scheme="https://imochen.com/tags/ThinkJS/"/>
    
      <category term="WebComponent" scheme="https://imochen.com/tags/WebComponent/"/>
    
  </entry>
  
</feed>
